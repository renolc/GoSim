// Generated by CoffeeScript 1.8.0
describe('A go game', function() {
  beforeEach(function() {
    jasmine.addMatchers({
      toInclude: function() {
        return {
          compare: function(actual, expected) {
            if (actual instanceof Cluster) {
              return {
                pass: actual.cells.indexOf(expected) !== -1
              };
            } else {
              return {
                pass: actual.indexOf(expected) !== -1
              };
            }
          }
        };
      },
      toBeA: function() {
        return {
          compare: function(actual, expected) {
            return {
              pass: actual instanceof expected
            };
          }
        };
      }
    });
    return this.game = new GoGame();
  });

  /*
  Game tests
   */
  it('should have a board', function() {
    return expect(this.game.board).toBeA(Board);
  });
  it('should start with black', function() {
    return expect(this.game.turn).toBe(Cell.PIECE.BLACK);
  });
  it('should alternate turns after passing', function() {
    this.game.pass();
    expect(this.game.turn).toBe(Cell.PIECE.WHITE);
    this.game.pass();
    return expect(this.game.turn).toBe(Cell.PIECE.BLACK);
  });

  /*
  Play tests
   */
  describe('play', function() {
    beforeEach(function() {
      this.originalTurn = this.game.turn;
      return this.cell = this.game.play(4, 5);
    });
    it('should return the cell played on', function() {
      return expect(this.cell).toBeA(Cell);
    });
    it('should set the value of the cell to the current turn', function() {
      return expect(this.cell.value).toBe(this.originalTurn);
    });
    it('should alternate turns', function() {
      expect(this.game.turn).toBe(Cell.PIECE.WHITE);
      this.game.play(0, 1);
      return expect(this.game.turn).toBe(Cell.PIECE.BLACK);
    });
    it('should create a cluster related to the cell that contains it', function() {
      expect(this.cell.cluster).toBeA(Cluster);
      return expect(this.cell.cluster).toInclude(this.cell);
    });
    it('should merge clusters when played next to a similar piece', function() {
      this.game.pass();
      this.cell2 = this.game.play(4, 4);
      expect(this.cell.cluster).toBe(this.cell2.cluster);
      expect(this.cell.cluster).toInclude(this.cell);
      return expect(this.cell.cluster).toInclude(this.cell2);
    });
    it('should not merge clusters when played next to an opposite piece', function() {
      this.cell2 = this.game.play(4, 4);
      return expect(this.cell.cluster).not.toBe(this.cell2.cluster);
    });

    /*
    Cluster tests
     */
    return describe('cluster', function() {
      beforeEach(function() {
        return this.cluster = this.cell.cluster;
      });
      return it('should contain the liberties of the default cells', function() {
        var liberties;
        liberties = this.cluster.liberties();
        expect(liberties).toEqual(this.cell.liberties());
        expect(liberties).toInclude(this.cell.up);
        expect(liberties).toInclude(this.cell.down);
        expect(liberties).toInclude(this.cell.left);
        return expect(liberties).toInclude(this.cell.right);
      });
    });
  });

  /*
  Board tests
   */
  return describe('board', function() {
    beforeEach(function() {
      return this.board = this.game.board;
    });
    it('should have a size of 9', function() {
      return expect(this.board.size).toBe(9);
    });
    it('should be composed of cells', function() {
      return expect(this.board.at(0, 0)).toBeA(Cell);
    });

    /*
    Cell tests
     */
    return describe('cell', function() {
      beforeEach(function() {
        return this.cell = this.board.at(3, 2);
      });
      it('should start as empty', function() {
        return expect(this.cell.value).toBe(Cell.PIECE.EMPTY);
      });
      it('should reference the cell above it', function() {
        return expect(this.cell.up).toBe(this.board.at(3, 1));
      });
      it('should reference the cell below it', function() {
        return expect(this.cell.down).toBe(this.board.at(3, 3));
      });
      it('should reference the cell to the left of it', function() {
        return expect(this.cell.left).toBe(this.board.at(2, 2));
      });
      it('should reference the cell to the right of it', function() {
        return expect(this.cell.right).toBe(this.board.at(4, 2));
      });
      return it('should reference all its surounding cells', function() {
        expect(this.cell.surrounding()).toBeA(Array);
        expect(this.cell.surrounding()).toInclude(this.cell.up);
        expect(this.cell.surrounding()).toInclude(this.cell.down);
        expect(this.cell.surrounding()).toInclude(this.cell.left);
        return expect(this.cell.surrounding()).toInclude(this.cell.right);
      });
    });
  });
});
