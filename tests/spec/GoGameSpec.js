// Generated by CoffeeScript 1.8.0
describe('A go game', function() {
  beforeEach(function() {
    jasmine.addMatchers({
      toInclude: function() {
        return {
          compare: function(actual, expected) {
            var e, value, _i, _len;
            if (actual instanceof Cluster) {
              return {
                pass: actual.cells.indexOf(expected) !== -1
              };
            } else {
              if (expected instanceof Array) {
                value = true;
                for (_i = 0, _len = expected.length; _i < _len; _i++) {
                  e = expected[_i];
                  if (actual.indexOf(e) === -1) {
                    value = false;
                  }
                }
                return {
                  pass: value
                };
              } else {
                return {
                  pass: actual.indexOf(expected) !== -1
                };
              }
            }
          }
        };
      },
      toBeA: function() {
        return {
          compare: function(actual, expected) {
            return {
              pass: actual instanceof expected
            };
          }
        };
      }
    });
    return this.game = new GoGame();
  });

  /*
  Game tests
   */
  it('should have a board', function() {
    return expect(this.game.board).toBeA(Board);
  });
  it('should start with black', function() {
    return expect(this.game.turn).toBe(Cell.PIECE.BLACK);
  });
  it('should alternate turns after passing', function() {
    this.game.pass();
    expect(this.game.turn).toBe(Cell.PIECE.WHITE);
    this.game.pass();
    return expect(this.game.turn).toBe(Cell.PIECE.BLACK);
  });

  /*
  Play tests
   */
  describe('play', function() {
    beforeEach(function() {
      this.originalTurn = this.game.turn;
      return this.cell = this.game.play(4, 3);
    });
    it('should return the cell played on when successful', function() {
      return expect(this.cell).toBeA(Cell);
    });
    it('should return false and reset the cell when invalid', function() {
      var originalTurn;
      this.game.pass();
      this.game.play(4, 1);
      this.game.pass();
      this.game.play(5, 2);
      this.game.pass();
      this.game.play(3, 2);
      originalTurn = this.game.turn;
      expect(this.game.play(4, 2)).toBe(false);
      expect(this.game.board.at(4, 2).value).toBe(Cell.PIECE.EMPTY);
      return expect(this.game.turn).toBe(originalTurn);
    });
    it('should set the value of the cell to the current turn', function() {
      return expect(this.cell.value).toBe(this.originalTurn);
    });
    it('should alternate turns', function() {
      expect(this.game.turn).toBe(Cell.PIECE.WHITE);
      this.game.play(0, 1);
      return expect(this.game.turn).toBe(Cell.PIECE.BLACK);
    });
    return it('should create a cluster related to the cell that contains it', function() {
      expect(this.cell.cluster).toBeA(Cluster);
      return expect(this.cell.cluster).toInclude(this.cell);
    });
  });

  /*
  Cluster tests
   */
  describe('cluster', function() {
    it('should contain the liberties of the default cells', function() {
      var cell, liberties;
      cell = this.game.play(4, 3);
      liberties = cell.cluster.liberties();
      expect(liberties).toEqual(cell.liberties());
      expect(liberties).toInclude(cell.up);
      expect(liberties).toInclude(cell.down);
      expect(liberties).toInclude(cell.left);
      return expect(liberties).toInclude(cell.right);
    });
    it('should merge clusters when played next to a similar piece', function() {
      var cell, cell2, cluster;
      cell = this.game.play(4, 3);
      this.game.pass();
      cell2 = this.game.play(4, 4);
      cluster = cell.cluster;
      expect(cluster.cells.length).toBe(2);
      expect(cluster).toBe(cell.cluster);
      expect(cluster).toBe(cell2.cluster);
      expect(cluster).toInclude(cell);
      return expect(cluster).toInclude(cell2);
    });
    it('should contain the liberties of all its cells', function() {
      var cell, cell2, liberties;
      cell = this.game.play(4, 3);
      this.game.pass();
      cell2 = this.game.play(4, 4);
      liberties = cell.cluster.liberties();
      expect(liberties).toInclude(cell.liberties());
      return expect(liberties).toInclude(cell2.liberties());
    });
    return it('should be removed if all liberties are gone', function() {
      this.game.play(4, 3);
      this.game.play(4, 2);
      this.game.pass();
      this.game.play(4, 4);
      this.game.pass();
      this.game.play(3, 3);
      this.game.pass();
      this.game.play(5, 3);
      return expect(this.game.board.at(4, 3).value).toBe(Cell.PIECE.EMPTY);
    });
  });

  /*
  Board tests
   */
  describe('board', function() {
    beforeEach(function() {
      return this.board = this.game.board;
    });
    it('should have a size of 9', function() {
      return expect(this.board.size).toBe(9);
    });
    return it('should be composed of cells', function() {
      return expect(this.board.at(0, 0)).toBeA(Cell);
    });
  });

  /*
  Cell tests
   */
  return describe('cell', function() {
    beforeEach(function() {
      return this.cell = this.game.board.at(3, 2);
    });
    it('should start as empty', function() {
      return expect(this.cell.value).toBe(Cell.PIECE.EMPTY);
    });
    it('should reference the cell above it', function() {
      return expect(this.cell.up).toBe(this.game.board.at(3, 1));
    });
    it('should reference the cell below it', function() {
      return expect(this.cell.down).toBe(this.game.board.at(3, 3));
    });
    it('should reference the cell to the left of it', function() {
      return expect(this.cell.left).toBe(this.game.board.at(2, 2));
    });
    it('should reference the cell to the right of it', function() {
      return expect(this.cell.right).toBe(this.game.board.at(4, 2));
    });
    return it('should reference all its surounding cells', function() {
      expect(this.cell.surrounding()).toBeA(Array);
      expect(this.cell.surrounding()).toInclude(this.cell.up);
      expect(this.cell.surrounding()).toInclude(this.cell.down);
      expect(this.cell.surrounding()).toInclude(this.cell.left);
      return expect(this.cell.surrounding()).toInclude(this.cell.right);
    });
  });
});
