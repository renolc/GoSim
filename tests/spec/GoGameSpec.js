// Generated by CoffeeScript 1.8.0
describe('A go game', function() {
  beforeEach(function() {
    jasmine.addMatchers({
      toBeEmpty: function() {
        return {
          compare: function(actual) {
            return {
              pass: actual.toString().indexOf('b') === -1 && actual.toString().indexOf('w') === -1
            };
          }
        };
      }
    });
    return this.game = new GoGame();
  });
  it('starts empty', function() {
    return expect(this.game).toBeEmpty();
  });
  it('should start with black', function() {
    return expect(this.game.turn).toEqual(GoGame.PIECE.BLACK);
  });
  it('should be able to chain commands', function() {
    this.game.play(0, 0).play(1, 0).pass();
    return expect(this.game.turn).toEqual(GoGame.PIECE.WHITE);
  });
  describe('when a player places a piece not on an edge', function() {
    beforeEach(function() {
      this.game.play(2, 3);
      return this.cell = this.game.board[2][3];
    });
    it('should not be empty', function() {
      return expect(this.cell.value).not.toEqual(GoGame.PIECE.EMPTY);
    });
    it('should alternate turns', function() {
      expect(this.game.turn).toEqual(GoGame.PIECE.WHITE);
      this.game.play(0, 0);
      return expect(this.game.turn).toEqual(GoGame.PIECE.BLACK);
    });
    return it('should reference all 4 cells around it', function() {
      expect(this.cell.surroundingCells().length).toEqual(4);
      expect(this.cell.up()).toBe(this.game.board[2][2]);
      expect(this.cell.down()).toBe(this.game.board[2][4]);
      expect(this.cell.left()).toBe(this.game.board[1][3]);
      return expect(this.cell.right()).toBe(this.game.board[3][3]);
    });
  });
  describe('when a player places a piece on the top edge', function() {
    beforeEach(function() {
      this.game.play(3, 0);
      return this.cell = this.game.board[3][0];
    });
    it('should not be empty', function() {
      return expect(this.cell.value).not.toEqual(GoGame.PIECE.EMPTY);
    });
    return it('should reference all 3 cells around it', function() {
      expect(this.cell.surroundingCells().length).toEqual(3);
      expect(this.cell.up()).toBe(null);
      expect(this.cell.down()).toBe(this.game.board[3][1]);
      expect(this.cell.left()).toBe(this.game.board[2][0]);
      return expect(this.cell.right()).toBe(this.game.board[4][0]);
    });
  });
  describe('when a player places a piece on the bottom edge', function() {
    beforeEach(function() {
      this.game.play(3, this.game.boardSize - 1);
      return this.cell = this.game.board[3][this.game.boardSize - 1];
    });
    it('should not be empty', function() {
      return expect(this.cell.value).not.toEqual(GoGame.PIECE.EMPTY);
    });
    return it('should reference all 3 cells around it', function() {
      expect(this.cell.surroundingCells().length).toEqual(3);
      expect(this.cell.up()).toBe(this.game.board[3][this.game.boardSize - 2]);
      expect(this.cell.down()).toBe(null);
      expect(this.cell.left()).toBe(this.game.board[2][this.game.boardSize - 1]);
      return expect(this.cell.right()).toBe(this.game.board[4][this.game.boardSize - 1]);
    });
  });
  describe('when a player places a piece on the left edge', function() {
    beforeEach(function() {
      this.game.play(0, 3);
      return this.cell = this.game.board[0][3];
    });
    it('should not be empty', function() {
      return expect(this.cell.value).not.toEqual(GoGame.PIECE.EMPTY);
    });
    return it('should reference all 3 cells around it', function() {
      expect(this.cell.surroundingCells().length).toEqual(3);
      expect(this.cell.up()).toBe(this.game.board[0][2]);
      expect(this.cell.down()).toBe(this.game.board[0][4]);
      expect(this.cell.left()).toBe(null);
      return expect(this.cell.right()).toBe(this.game.board[1][3]);
    });
  });
  describe('when a player places a piece on the right edge', function() {
    beforeEach(function() {
      this.game.play(this.game.boardSize - 1, 3);
      return this.cell = this.game.board[this.game.boardSize - 1][3];
    });
    it('should not be empty', function() {
      return expect(this.cell.value).not.toEqual(GoGame.PIECE.EMPTY);
    });
    return it('should reference all 3 cells around it', function() {
      expect(this.cell.surroundingCells().length).toEqual(3);
      expect(this.cell.up()).toBe(this.game.board[this.game.boardSize - 1][2]);
      expect(this.cell.down()).toBe(this.game.board[this.game.boardSize - 1][4]);
      expect(this.cell.left()).toBe(this.game.board[this.game.boardSize - 2][3]);
      return expect(this.cell.right()).toBe(null);
    });
  });
  describe('when a player places a piece in the top left corner', function() {
    beforeEach(function() {
      this.game.play(0, 0);
      return this.cell = this.game.board[0][0];
    });
    it('should not be empty', function() {
      return expect(this.cell.value).not.toEqual(GoGame.PIECE.EMPTY);
    });
    return it('should reference all 2 cells around it', function() {
      expect(this.cell.surroundingCells().length).toEqual(2);
      expect(this.cell.up()).toBe(null);
      expect(this.cell.down()).toBe(this.game.board[0][1]);
      expect(this.cell.left()).toBe(null);
      return expect(this.cell.right()).toBe(this.game.board[1][0]);
    });
  });
  describe('when a player places a piece in the top right corner', function() {
    beforeEach(function() {
      this.game.play(this.game.boardSize - 1, 0);
      return this.cell = this.game.board[this.game.boardSize - 1][0];
    });
    it('should not be empty', function() {
      return expect(this.cell.value).not.toEqual(GoGame.PIECE.EMPTY);
    });
    return it('should reference all 2 cells around it', function() {
      expect(this.cell.surroundingCells().length).toEqual(2);
      expect(this.cell.up()).toBe(null);
      expect(this.cell.down()).toBe(this.game.board[this.game.boardSize - 1][1]);
      expect(this.cell.left()).toBe(this.game.board[this.game.boardSize - 2][0]);
      return expect(this.cell.right()).toBe(null);
    });
  });
  describe('when a player places a piece in the bottom left corner', function() {
    beforeEach(function() {
      this.game.play(0, this.game.boardSize - 1);
      return this.cell = this.game.board[0][this.game.boardSize - 1];
    });
    it('should not be empty', function() {
      return expect(this.cell.value).not.toEqual(GoGame.PIECE.EMPTY);
    });
    return it('should reference all 2 cells around it', function() {
      expect(this.cell.surroundingCells().length).toEqual(2);
      expect(this.cell.up()).toBe(this.game.board[0][this.game.boardSize - 2]);
      expect(this.cell.down()).toBe(null);
      expect(this.cell.left()).toBe(null);
      return expect(this.cell.right()).toBe(this.game.board[1][this.game.boardSize - 1]);
    });
  });
  describe('when a player places a piece in the bottom right corner', function() {
    beforeEach(function() {
      this.game.play(this.game.boardSize - 1, this.game.boardSize - 1);
      return this.cell = this.game.board[this.game.boardSize - 1][this.game.boardSize - 1];
    });
    it('should not be empty', function() {
      return expect(this.cell.value).not.toEqual(GoGame.PIECE.EMPTY);
    });
    return it('should reference all 2 cells around it', function() {
      expect(this.cell.surroundingCells().length).toEqual(2);
      expect(this.cell.up()).toBe(this.game.board[this.game.boardSize - 1][this.game.boardSize - 2]);
      expect(this.cell.down()).toBe(null);
      expect(this.cell.left()).toBe(this.game.board[this.game.boardSize - 2][this.game.boardSize - 1]);
      return expect(this.cell.right()).toBe(null);
    });
  });
  return describe('when a player passes', function() {
    var originalBoard;
    originalBoard = null;
    beforeEach(function() {
      originalBoard = this.game.toString();
      return this.game.pass();
    });
    it('should not change the board', function() {
      return expect(this.game.toString()).toEqual(originalBoard);
    });
    return it('should alternate turns', function() {
      expect(this.game.turn).toEqual(GoGame.PIECE.WHITE);
      this.game.pass();
      return expect(this.game.turn).toEqual(GoGame.PIECE.BLACK);
    });
  });
});
