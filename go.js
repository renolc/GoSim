// Generated by CoffeeScript 1.7.1
var GoGame,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

GoGame = (function() {
  var Images, Position;

  GoGame.prototype.DEBUG = null;

  GoGame.prototype.canvas = null;

  GoGame.prototype.drawingContext = null;

  GoGame.prototype.board = null;

  GoGame.prototype.mousePosition = null;

  GoGame.prototype.turn = null;

  GoGame.prototype.clusters = null;

  GoGame.prototype.cellSize = 20;

  GoGame.prototype.boardSize = 19;

  GoGame.prototype.FPS = 30;

  GoGame.prototype.currentAlpha = 0.5;

  Position = {
    UP: 'up',
    DOWN: 'down',
    LEFT: 'left',
    RIGHT: 'right'
  };

  Images = {
    INERSECTION: new Image(),
    TOPLEFT: new Image(),
    TOPRIGHT: new Image(),
    BOTTOMLEFT: new Image(),
    BOTTOMRIGHT: new Image(),
    TOP: new Image(),
    RIGHT: new Image(),
    LEFT: new Image(),
    BOTTOM: new Image(),
    BLACK: new Image(),
    WHITE: new Image(),
    DEBUG_LIBERTY: new Image()
  };

  function GoGame(debug) {
    if (debug == null) {
      debug = false;
    }
    this.onMouseClick = __bind(this.onMouseClick, this);
    this.onMouseOut = __bind(this.onMouseOut, this);
    this.onMouseMove = __bind(this.onMouseMove, this);
    this.DEBUG = debug;
    this.initCanvasAndContext();
    this.initBoard();
    this.loadImagesAndDraw();
  }

  GoGame.prototype.initCanvasAndContext = function() {
    this.canvas = document.createElement('canvas');
    this.canvas.height = this.canvas.width = this.cellSize * this.boardSize;
    this.drawingContext = this.canvas.getContext('2d');
    document.body.appendChild(this.canvas);
    this.canvas.onmousemove = this.onMouseMove;
    this.canvas.onclick = this.onMouseClick;
    return this.canvas.onmouseout = this.onMouseOut;
  };

  GoGame.prototype.initBoard = function() {
    var col, row, _i, _ref, _results;
    this.turn = Images.BLACK;
    this.clusters = [];
    this.board = [];
    _results = [];
    for (row = _i = 0, _ref = this.boardSize; 0 <= _ref ? _i < _ref : _i > _ref; row = 0 <= _ref ? ++_i : --_i) {
      this.board[row] = [];
      _results.push((function() {
        var _j, _ref1, _results1;
        _results1 = [];
        for (col = _j = 0, _ref1 = this.boardSize; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; col = 0 <= _ref1 ? ++_j : --_j) {
          _results1.push(this.board[row][col] = this.createCell(row, col));
        }
        return _results1;
      }).call(this));
    }
    return _results;
  };

  GoGame.prototype.createCell = function(row, col) {
    return {
      piece: null,
      cluster: null,
      row: row,
      col: col,
      getNeighbors: (function(_this) {
        return function() {
          var cell, k, neighbors, v;
          cell = _this.board[row][col];
          neighbors = [];
          for (k in Position) {
            v = Position[k];
            neighbors.push(cell.getNeighbor(v));
          }
          return neighbors;
        };
      })(this),
      getNeighbor: (function(_this) {
        return function(position) {
          var _ref, _ref1;
          switch (position) {
            case Position.UP:
              return (_ref = _this.board[row - 1]) != null ? _ref[col] : void 0;
            case Position.DOWN:
              return (_ref1 = _this.board[row + 1]) != null ? _ref1[col] : void 0;
            case Position.LEFT:
              return _this.board[row][col - 1];
            case Position.RIGHT:
              return _this.board[row][col + 1];
          }
        };
      })(this),
      setCluster: (function(_this) {
        return function(cluster) {
          var cell;
          cell = _this.board[row][col];
          cell.cluster = cluster;
          return _this.addCellToCluster(cell, cluster);
        };
      })(this)
    };
  };

  GoGame.prototype.createCluster = function(cell) {
    return {
      cells: [cell],
      liberties: []
    };
  };

  GoGame.prototype.loadImagesAndDraw = function() {
    var imagesLoadedCount, k, v;
    imagesLoadedCount = 0;
    for (k in Images) {
      v = Images[k];
      imagesLoadedCount++;
      v.onload = (function(_this) {
        return function() {
          imagesLoadedCount--;
          if (imagesLoadedCount === 0) {
            return _this.draw();
          }
        };
      })(this);
    }
    Images.TOP.src = 'img/topEdge.png';
    Images.RIGHT.src = 'img/rightEdge.png';
    Images.BOTTOM.src = 'img/bottomEdge.png';
    Images.LEFT.src = 'img/leftEdge.png';
    Images.TOPRIGHT.src = 'img/topRight.png';
    Images.TOPLEFT.src = 'img/topLeft.png';
    Images.BOTTOMRIGHT.src = 'img/bottomRight.png';
    Images.BOTTOMLEFT.src = 'img/bottomLeft.png';
    Images.INERSECTION.src = 'img/intersection.png';
    Images.BLACK.src = 'img/black.png';
    Images.WHITE.src = 'img/white.png';
    return Images.DEBUG_LIBERTY.src = 'img/debugLiberty.png';
  };

  GoGame.prototype.draw = function() {
    var col, fillStyle, row, _i, _j, _ref, _ref1;
    fillStyle = 'rgb(195, 142, 72)';
    this.drawingContext.fillStyle = fillStyle;
    this.drawingContext.fillRect(0, 0, this.canvas.width, this.canvas.height);
    for (row = _i = 0, _ref = this.boardSize; 0 <= _ref ? _i < _ref : _i > _ref; row = 0 <= _ref ? ++_i : --_i) {
      for (col = _j = 0, _ref1 = this.boardSize; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; col = 0 <= _ref1 ? ++_j : --_j) {
        this.drawCell(this.board[row][col]);
      }
    }
    this.drawCurrentPiece();
    if (this.DEBUG) {
      this.drawDEBUGLiberties();
    }
    return setTimeout(((function(_this) {
      return function() {
        return _this.draw();
      };
    })(this)), 1000 / this.FPS);
  };

  GoGame.prototype.drawCurrentPiece = function() {
    var cell;
    if (this.mousePosition) {
      cell = this.board[this.mousePosition.row][this.mousePosition.col];
      if (!(cell != null ? cell.piece : void 0)) {
        this.drawingContext.save();
        this.drawingContext.globalAlpha = this.currentAlpha;
        this.drawImage(this.turn, this.mousePosition.row, this.mousePosition.col);
        return this.drawingContext.restore();
      }
    }
  };

  GoGame.prototype.drawCell = function(cell) {
    var img;
    if (cell.row === 0 && cell.col === 0) {
      img = Images.TOPLEFT;
    } else if (cell.row === 0 && cell.col === this.boardSize - 1) {
      img = Images.TOPRIGHT;
    } else if (cell.row === this.boardSize - 1 && cell.col === 0) {
      img = Images.BOTTOMLEFT;
    } else if (cell.row === this.boardSize - 1 && cell.col === this.boardSize - 1) {
      img = Images.BOTTOMRIGHT;
    } else if (cell.row === 0) {
      img = Images.TOP;
    } else if (cell.row === this.boardSize - 1) {
      img = Images.BOTTOM;
    } else if (cell.col === 0) {
      img = Images.LEFT;
    } else if (cell.col === this.boardSize - 1) {
      img = Images.RIGHT;
    } else {
      img = Images.INERSECTION;
    }
    this.drawImage(img, cell.row, cell.col);
    if (cell.piece) {
      return this.drawImage(cell.piece, cell.row, cell.col);
    }
  };

  GoGame.prototype.drawDEBUGLiberties = function() {
    var cell, cluster, n, _i, _len, _ref, _results;
    _ref = this.clusters;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      cluster = _ref[_i];
      _results.push((function() {
        var _j, _len1, _ref1, _results1;
        _ref1 = cluster.cells;
        _results1 = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          cell = _ref1[_j];
          _results1.push((function() {
            var _k, _len2, _ref2, _results2;
            _ref2 = cell.getNeighbors();
            _results2 = [];
            for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
              n = _ref2[_k];
              if (!(n != null ? n.piece : void 0)) {
                _results2.push(this.drawImage(Images.DEBUG_LIBERTY, n != null ? n.row : void 0, n != null ? n.col : void 0));
              } else {
                _results2.push(void 0);
              }
            }
            return _results2;
          }).call(this));
        }
        return _results1;
      }).call(this));
    }
    return _results;
  };

  GoGame.prototype.onMouseMove = function(e) {
    if (e.offsetX) {
      return this.mousePosition = {
        col: Math.floor(e.offsetX / this.cellSize),
        row: Math.floor(e.offsetY / this.cellSize)
      };
    } else if (e.layerX) {
      return this.mousePosition = {
        col: Math.floor(e.layerX / this.cellSize),
        row: Math.floor(e.layerY / this.cellSize)
      };
    }
  };

  GoGame.prototype.onMouseOut = function() {
    return this.mousePosition = null;
  };

  GoGame.prototype.onMouseClick = function() {
    var cell;
    cell = this.board[this.mousePosition.row][this.mousePosition.col];
    this.placePiece(cell);
    if (this.DEBUG) {
      return console.log(cell.cluster.liberties);
    }
  };

  GoGame.prototype.nextTurn = function() {
    return this.turn = this.turn === Images.BLACK ? Images.WHITE : Images.BLACK;
  };

  GoGame.prototype.placePiece = function(cell) {
    var success;
    if (cell && !cell.piece) {
      cell.piece = this.turn;
      success = this.joinCluster(cell);
      if (success) {
        return this.nextTurn();
      } else {
        return cell.piece = null;
      }
    }
  };

  GoGame.prototype.joinCluster = function(cell) {
    var clustersToCheck, n, _i, _len, _ref;
    clustersToCheck = [];
    _ref = cell.getNeighbors();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      n = _ref[_i];
      if (n != null ? n.piece : void 0) {
        if (n.piece === cell.piece) {
          if (!cell.cluster) {
            cell.setCluster(n.cluster);
          } else if (n.cluster !== cell.cluster) {
            this.migrateCluster(n.cluster, cell.cluster);
          }
        } else {
          if (clustersToCheck.indexOf(n.cluster) === -1) {
            clustersToCheck.push(n.cluster);
          }
        }
      }
    }
    if (!cell.cluster) {
      cell.cluster = this.createCluster(cell);
    }
    if (this.clusters.indexOf(cell.cluster) === -1) {
      this.clusters.push(cell.cluster);
    }
    return this.updateLiberties(clustersToCheck, cell.cluster);
  };

  GoGame.prototype.updateLiberties = function(clusters, currentCluster) {
    var cell, cluster, n, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2, _ref3;
    for (_i = 0, _len = clusters.length; _i < _len; _i++) {
      cluster = clusters[_i];
      if (cluster) {
        cluster.liberties = [];
        _ref = cluster.cells;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          cell = _ref[_j];
          _ref1 = cell.getNeighbors();
          for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
            n = _ref1[_k];
            if (n && !n.piece) {
              cluster.liberties.push(n);
            }
          }
        }
        if (cluster.liberties.length === 0) {
          this.removeCluster(cluster);
        }
      }
    }
    currentCluster.liberties = [];
    _ref2 = currentCluster.cells;
    for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {
      cell = _ref2[_l];
      _ref3 = cell.getNeighbors();
      for (_m = 0, _len4 = _ref3.length; _m < _len4; _m++) {
        n = _ref3[_m];
        if (n && !n.piece) {
          currentCluster.liberties.push(n);
        }
      }
    }
    if (currentCluster.liberties.length === 0) {
      return false;
    }
    return true;
  };

  GoGame.prototype.drawImage = function(img, row, col) {
    return this.drawingContext.drawImage(img, col * this.cellSize, row * this.cellSize, this.cellSize, this.cellSize);
  };

  GoGame.prototype.addCellToCluster = function(cell, cluster) {
    return cluster.cells.push(cell);
  };

  GoGame.prototype.migrateCluster = function(from, to) {
    var cell, _i, _len, _ref;
    _ref = from.cells;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      cell = _ref[_i];
      cell.setCluster(to);
    }
    from.cells = [];
    return this.removeFromArray(from, this.clusters);
  };

  GoGame.prototype.removeFromArray = function(toRemove, array) {
    return array.splice(array.indexOf(toRemove), 1);
  };

  GoGame.prototype.removeCluster = function(cluster) {
    var cell, _i, _len, _ref;
    _ref = cluster.cells;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      cell = _ref[_i];
      cell.piece = null;
    }
    return this.removeFromArray(cluster, this.clusters);
  };

  return GoGame;

})();

window.onload = function() {
  return new GoGame();
};
